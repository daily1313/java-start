## 김영한의 자바 입문 - 코드로 시작하는 자바 첫걸음

### 자바 표준 스펙과 구현

#### 자바 표준 스펙 
- 자바가 어떻게 만들어지는지에 대한 설계도 및 문서
- 표준 스펙을 기반으로 여러 회사에서 실제 작동하는 자바 개발

#### 자바 구현
- 여러 회사에서 자바 표준 스펙에 맞춰 실제 작동하는 자바 프로그램 개발
- 각각 장단점이 존재, ex) Amazon Corretto는 AWS에 최적화
- 각 회사들은 대부분 윈도우, MAC, 리눅스와 같이 다양한 OS에서 작동하는 버전의 자바도 함께 제공

### 컴파일과 실행
- 자바 프로그램은 컴파일과 실행 단계를 거칩니다
- 자바 컴파일러에 의해 (javac 프로그램) 소스 코드를 컴파일 (.java -> .class 파일 생성)
- 자바 소스 코드를 바이트코드로 변환하며 자바 가상 머신에서 더 빠르게 실행될 수 있게 최적화 및 문법 오류 검출
- 자바 가상 머신(JVM)에 의해 프로그램 실행 및 작동

### IDE와 자바
- Intellij는 내부에 자바를 편리하게 설치하고 관리할 수 있는 기능 제공
- 이 기능을 사용하면 인텔리제이를 통해 자바를 편리하게 다운로드 받고 실행할 수 있습니다.
- OS에 별도로 설치하는 것도 가능
- Intellij에서는 자바 코드를 컴파일할 때, javac 프로그램을 직접 사용해야 하는 과정을 대체할 수 있습니다.


### 자바와 운영체제 독립성
- 일반적인 다른 프로그램은 다른 운영체제에서 실행이 불가능하지만, 자바는 OS에 구애받지 않고, Java가 설치된 모든 OS에서 실행이 가능합니다.
- OS에 맞춰 개발하지 않아도 되고, 자바에 맞춰 개발하면 됩니다.

### 변수명 명명 규칙
- 변수명 이름은 숫자로 시작할 수 없습니다. 그러나 숫자를 이름에 포함하는 것은 가능합니다.
- 이름에 공백이 들어갈 수 없으며, 자바의 예약어를 변수 이름으로 사용할 수 없습니다 (int, class, public)
- 변수 이름에는 영문자, 숫자, 달러 기호 및 밑줄만 사용할 수 있습니다
- 변수 이름은 소문자로 시작하는 것이 일반적이고, 그 이후의 각 단어는 대문자로 시작하는 낙타 표기법(camel case) 사용 (ex) orderDetail, myAccount)

### 클래스 명명 규칙
- 클래스는 대문자로 시작하고, 나머지는 모두 대문자로 시작합니다.
- 클래스는 첫글자 대문자, 나머지는 모두 첫글자 소문자로 시작 + 낙타 표기법
- 변수 이름은 의미있고, 그 용도를 명확하게 설명해야 합니다
- ex) 클래스: Person, OrderDetail
- ex) 변수를 포함한 나머지: firstName, userAccount
- 예외
  - 상수는 모두 대문자를 사용하고 언더바로 구분합니다. (USER_LIMIT)
  - 패키지는 모두 소문자를 사용 (org.spring.boot)

### 전위, 후위 증감연산자
- 전위(Prefix) 증감 연산자: 증감 연산이 먼저 수행된 후 나머지 연산이 수행됩니다.
- 후위(Postfix) 증감 연산자: 다른 연산이 먼저 수행된 후 증감 연산이 수행됩니다. 

### 비교 연산자
- ==: 동등성(equal to)
- !=: 불일치(not equal to)
- (>: 크다(greater than))
- (<: 작다(less than))
- (>=: 크거나 같다(greater than or equal to))
- (<=: 작거나 같다(less than or equal to))

### =, ==
- =: 대입 연산자, 변수의 값을 대입합니다.
- ==: 동등한지 확인하는 비교 연산자
- 문자열이 같은지 비교할 때는 equals() 메서드 사용, ==는 객체 비교, equals는 값 비교

### 삼항 연산자
- (조건) ? 참_표현식 : 거짓_표현식
- 삼항 연산자는 항이 3개라는 뜻입니다. 조건, 참_표현식, 거짓_표현식 이렇게 항이 3개입니다. 자바에서 유일하게 항이 3개인 연산자여서 
삼항 연산자라고 부릅니다.

### do-while
- 조건에 관계없이 무조건 한 번은 실행한다는 점에서 while문과 차이가 있습니다.

### for vs while
#### for 
- 장점
  - 초기화, 조건체크, 반복 후의 작업을 한 줄에서 처리가 가능하여 편리합니다.
  - 정해진 횟수만큼의 반복을 수행하는 경우에 사용하기 적합합니다.
  - 루트 변수의 범위가 for 루프 블록에 제한되므로, 다른 곳에서 이 변수를 실수로 변경할 가능성이 적습니다.
- 단점
  - 루프의 조건이 루프 내부에서 변경되는 경우, for 루프는 관리하기 어렵습니다.
  - 복잡한 조건을 가진 반복문을 작성하기에는 while문이 적합할 수 있습니다.
#### while
- 장점
  - 루프의 조건이 루프 내부에서 변경되는 경우, while 루프는 이를 관리하기 쉽습니다.
  - for 루프보다 더 복잡한 조건과 시나리오에 적합
  - 조건이 충족되는 동안 계속해서 루프를 실행하며, 종료 시점을 명확하게 알 수 없는 경우에 유용합니다.
- 단점
  - 초기화, 조건 체크, 반복 후의 작업이 분산되어 있어 코드를 이해하거나 작성하기 어려울 수 있습니다.
  - 루프 변수가 while 블록 바깥에서도 접근이 가능하므로, 이 변수를 실수로 변경하는 상황이 발생할 수 있습니다.

### 스코프(Scope)
- 변수의 접근 가능한 범위를 나타냅니다.
- 스코프 존재 이유
  - 비효율적인 메모리 사용을 방지하고, 코드 복잡성이 증가하는 것을 막기 위함입니다.
  
### 형변환
#### 자동 형변환 (묵시적 형변환)
- 작은 범위 숫자 타입에서 큰 범위 숫자 타입으로 형을 변경하는 것(자동으로 변환)
#### 명시적 형변환 
- 큰 범위에서 작은 범위로 형을 변경하는 것(개발자가 직접 변환해야 합니다)
#### 오버플로우
- 기존 범위를 초과하여 표현할 때 전혀 다른 숫자가 표기되는 것. (시계가 한바퀴 돈 것 처럼 다시 처음부터 시작)
#### 자바에서의 계산
- 같은 타입끼리의 계산은 같은 타입의 결과를 냅니다.
- 서로 다른 타입의 계산은 큰 범위로 자동 형변환이 일어납니다.

### 배열
- 같은 타입의 변수를 반복해서 선언하고 반복해서 사용하는 문제 해결
- 번호와 번호에 대응하는 데이터들로 이루어진 자료 구조
- 선언 예시: int[] students = new int[5];

### 기본형 vs 참조형
- 기본형(Primitive Type): int, long, double, boolean 처럼 변수에 사용할 값을 직접 넣을 수 있는 데이터 타입 
- 참조형(Reference Type): int[] students와 같이 데이터에 접근하기 위한 참조(주소)를 저장하는 데이터 타입

### 배열이 참조형을 사용하는 이유
- 동적으로 사이즈를 변경하기 위해 사용
- 예시를 들어, Scanner를 사용해서 사용자 입력에 따라 size 변수 값이 변하고, 생성되는 배열의 크기도 달라질 수 있습니다. (동적 메모리 할당)
- 기본형은 선언과 동시에 사이즈가 정적으로 정해지지만, 참조형을 사용하면 이처럼 동적으로 크기가 변해서 유연성을 제공할 수 있습니다.
- 기본형은 사용할 값을 직접 저장하고, 참조형은 메모리에 저장된 배열이나 객체의 참조를 저장합니다. 이로 인해 참조형은 더 복잡한 데이터 구조를 만들고 관리할 수 있습니다.
- 기본형은 더 빠르고 메모리를 효율적으로 처리합니다.

### 향상된 for문 (Enhanced For Loop, for-each문)
- 각각의 요소를 탐색
- 특정 인덱스 값을 직접 사용해야 하는 경우에는 향상된 for문 사용 X
```aidl
for(변수: 배열 또는 컬렉션) {

}
```

### 함수
- 자바에서는 함수를 메서드라고 부릅니다. (특정 작업을 수행하기 위한 명령문의 집합)
- 필요한 기능을 미리 정의해두고 필요할 때 마다 호출해서 사용할 수 있습니다.
```aidl
public static int add(int a, int b) // 메서드 정의{ 
    System.out.println(a + "+" + b + " 연산 수행"); 
    int sum = a + b;
    return sum; // 메서드 본문 (메서드를 호출하는 곳에서는 메서드 선언은 알지만 메서드 본문은 모릅니다)
}
```
- public static
  - public: 다른 클래스에 호출할 수 있는 메서드
  - static: 객체를 생성하지 않고 호출할 수 있는 정적 메서드
- int add(int a, int b)
  - int: 반환 타입을 정의, 메서드의 실행 결과를 반환할 때 사용할 반환 타입 지정
  - add: 메서드에 이름을 부여, 이 이름으로 메서드 호출 가능
  - (int a, int b): 메서드를 호출할 때 전달하는 입력 값
- 메서드 호출
  - int sum1 = add(5, 10)

### 메서드 호출과 용어 정리
- 메서드를 호출할 때는 다음과 같이 메서드에 넘기는 값과 매개변수(파라미터)의 타입이 맞아야 합니다. (순서와 갯수도 맞아야 합니다.)
  - 호출: call("hello", 20)
  - 메서드 정의: int call(String str, int age)
- 인수(Argument)
  - 메서드 내부로 들어가는 값
- 매개변수(Parameter)
  - 중간에서 전달하는 변수
  - 메서드 호출부와 메서드 내부 사이에서 값을 전달하는 역할을 하는 변수

### 메서드 정의
```aidl
public static int add(int a, int b) { 
//메서드 본문, 실행 코드
}

제어자 반환타입 메서드이름(매개변수 목록) { 
  메서드 본문
}
```
- 제어자(Modifier): public, static과 같은 부분
- 반환 타입(Return type): 메서드가 실행 된 후 반환하는 데이터의 타입을 지정, 메서드가 값을 반환하지 않으면 void
- 메서드 이름(Method Name): 메서드의 이름, 메서드를 호출하는 데 사용
- 매개변수(Parameter): 입력 값으로, 메서드 내부에서 사용할 수 있는 변수, 매개변수는 옵션입니다. 입력값이 필요 없는 메서드는 매개변수를 지정하지 않아도 됩니다.
- 메서드 본문(Method Body): 실제 메서드의 코드가 위치. 중괄호 {} 사이에 코드 작성

### void와 return 생략
- 모든 메서드는 항상 return을 호출해야 합니다. 그런데 반환 타입 void의 경우에는 예외로 printFooter()와 같이 생략해야 됩니다.
- 자바가 반환 타입이 없는 경우에는 return을 마지막줄에 넣어줍니다. return을 만나면 해당 메서드는 종료됩니다.
- 반환 타입이 있으면 반드시 return을 사용하여 값을 반환해야 합니다 

### 메서드 호출과 값 전달
- 자바는 항상 변수의 값을 복사해서 대입합니다.

### 메서드 오버로딩
- 이름이 같고 매개변수가 다른 메서드를 여러개 정의하는 것
- 메서드의 이름이 같아도 매개변수의 타입 및 순서가 다르면 오버로딩 할 수 있습니다.
- 하지만, 메서드 시그니처 (메서드 이름 + 매개변수 타입(순서))가 같다면, 오버로딩은 안됩니다.
```aidl
add(int a, int b)
add(int a, int b, int c)
add(double a, double b)
```

### 변수명 vs 메서드명
- 변수 이름은 일반적으로 명사를 사용합니다. 하지만, 메서드는 무언가 동작하는데 사용하기 때문에 일반적으로 동사로 시작합니다.
- 이런 차이점 외에는 변수 이름과 메서드 이름에 대한 규칙은 둘다 같습니다.
  - 변수명 예): customerName, totalSum, employeeCount, isAvailable
  - 메서드명 예): printReport(), calculateSum(), addCustomer()

### 메서드 사용의 장점
- 코드 재사용: 메서드는 특정 기능을 캡슐화하므로, 필요할 때마다 그 기능을 다시 작성할 필요 없이 해당 메서드를 호출함으로써 코드를 재사용할 수 있습니다.
- 코드의 가독성: 이름이 부여된 메서드는 코드가 수행하는 작업을 명확하게 나타내므로, 코드를 읽는 사람에게 추가적인 문맥을 제공합니다.
- 모듈성: 큰 프로그램을 작성, 관리 가능한 부분으로 나눌 수 있습니다. 이는 코드의 가독성을 향상시키고 디버깅을 쉽게 만듭니다.
- 코드 유지 관리: 메서드를 사용하면, 코드의 특정 부분에서 문제가 발생하거나 업데이트가 필요한 경우 해당 메서드만 수정하면 됩니다.
- 재사용성과 확장성: 잘 설계된 메서드는 다른 프로그램이나 프로젝트에서도 재사용할 수 있으며, 새로운 기능을 추가하거나 기존 기능을 확장하는 데 유용합니다.
- 추상화: 메서드를 사용하는 곳에서는 메서드의 구현을 몰라도 됩니다. 프로그램의 다른 부분에서는 복잡한 내부 작업에 대해 알 필요 없이 메서드를 사용할 수 있습니다.
- 테스트와 디버깅 용이성: 개별 메서드는 독립적으로 테스트하고 디버그할 수 있습니다. 이는 코드의 문제를 신속하게 찾고 수정하는 데 도움이 됩니다.

